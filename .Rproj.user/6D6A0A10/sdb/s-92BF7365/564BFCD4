{
    "collab_server" : "",
    "contents" : "probeID2position <- function (probe_IDs){ #conversion from illumina human450 methylation array ID to genomic position (R version 3.2 or later)\n  library(\"FDb.InfiniumMethylation.hg19\")\n  library(\"lumi\")\n  ##conversion of target probe IDs to positions\n  hm450 <- get450k()\n  probes <- hm450[probe_IDs]\n  CHR37 <- as.vector(seqnames(probes))\n  CPG37 <- as.vector(start(ranges(probes)))\n  positions <- cbind(CHR37, CPG37)\n  rownames(positions) <- probe_IDs\n  return(positions)\n}\n\nprobeID2position_EPIC <- function (probe_IDs){ #conversion from illumina humanEPIC methylation array ID to genomic position (R version 3.2 or later)\n  ##conversion of target probe IDs to positions\n  probes <- probe_IDs\n  CHR37 <- as.vector (EPICanno[which(EPICanno[,1]%in% probes), \"CHR\"])\n  CHR37 <- paste(\"chr\", CHR37, sep=\"\")\n  CPG37 <- as.vector (EPICanno[which(EPICanno[,1] %in% probes), \"MAPINFO\"])\n  positions <- cbind(CHR37, CPG37)\n  return(positions)\n}\n\nstratSampling <- function(target_IDs, allProbe_IDs){\t#stratified sampling based on DMPs. categolies are CpG island, CpG shore and non-CGI/non-shore\n  library(\"FDb.InfiniumMethylation.hg19\")\n  library(\"lumi\")\n  hm450 <- get450k()\n  probes <- hm450[target_IDs]\n  all_probes <- hm450[allProbe_IDs]\n  ##Stratified sampling of same number of probes from ctrl probe list based on categolies of CGIs, shores, and non CGIs\n  ##definition of CpG island and shore\n  data(hg19.islands)\n  hg19.shores <- c(flank(hg19.islands, 2000, start=TRUE),flank(hg19.islands, 2000, start=FALSE))\t#definign of shores (defined as 2kb up/down stream from CGI)\n  ## identification of DMPs in each categolies\n  CGI.probes <- subsetByOverlaps(probes, hg19.islands)\t#identification of CGI DMPs\n  shore.probes <- subsetByOverlaps(probes, hg19.shores)\t#identification of shore DMPs\n  shore.probes <- shore.probes[!shore.probes %in% CGI.probes] #In case of overlap to two categolies, CGI is priolity\n\n  ## number of DMPs in each categilies\n  nCGI.probes <- length(CGI.probes)\t#number of CGI DMPs\n  nshore.probes <- length(shore.probes)\t#number of shore DMPs\n  nnonCGI.probes <- length(probes)-nCGI.probes-nshore.probes\t#number of non-CGI/non-shore DMPs\n\n  ##Categolization of all probes into the categolies\n  CGI.ctrlProbeList <-names(subsetByOverlaps(all_probes, hg19.islands))\t#identification of all CGI probes\n  shore.ctrlProbeList <- names(subsetByOverlaps(all_probes, hg19.shores)) #identification of all shore probes\n  shore.ctrlProbeList <- shore.ctrlProbeList[!shore.ctrlProbeList %in%CGI.ctrlProbeList]#In case of overlap to two categolies, CGI is priolity\n  nonCGI.ctrlProbeList <- setdiff(setdiff(allProbe_IDs, names(CGI.ctrlProbeList)), names(shore.ctrlProbeList))\t#identification of all no-CGI/non-shore probes\n\n  ##number of probes in each categolies\n  nCGI.ctrlProbeList <- length(CGI.ctrlProbeList) #number of all CGI probes\n  nshore.ctrlProbeList <- length(shore.ctrlProbeList)\t#number of all shore probes\n  nnonCGI.ctrlProbeList <- length (nonCGI.ctrlProbeList)\t#number of all non-CGI/non-shore/probes\n\n  ##ramdom sampling from each categolies\n  CGI.runProbeList <- CGI.ctrlProbeList[floor(runif(nCGI.probes, 1 ,nCGI.ctrlProbeList))]\t#random sampling from CGI probes\n  shore.runProbeList <- shore.ctrlProbeList[floor(runif(nshore.probes, 1 ,nshore.ctrlProbeList))]\t#random sampling from shre probes\n  nonCGI.runProbeList <- nonCGI.ctrlProbeList[floor(runif(nnonCGI.probes, 1 ,nnonCGI.ctrlProbeList))] \t#random sampling from non-CGI/nin-shore probes\n  runProbeList <- c(CGI.runProbeList, shore.runProbeList, nonCGI.runProbeList)\n  return (runProbeList)\n\n}\n\nstratSampling_EPIC <- function(target_IDs, allProbe_IDs){\t#stratified sampling based on DMPs. categolies are CpG island, CpG shore and non-CGI/non-shore\n  library(\"FDb.InfiniumMethylation.hg19\")\n  selEPICanno <- cbind(EPICanno[,c(\"CHR\",\"MAPINFO\",\"MAPINFO\", \"IlmnID\")],\n                       score=rep(0, nrow(EPICanno)),strand=rep(\"*\", nrow(EPICanno)))\n  selEPICanno[,1] <- paste(\"chr\", selEPICanno[,1], sep=\"\")\n  colnames(selEPICanno) <-c(\"chr\", \"start\", \"end\", \"id\", \"score\", \"strand\")\n  selEPICanno <- na.omit(selEPICanno)\n  EPICannobed <- with(selEPICanno, GRanges(chr, IRanges(start, end), strand, score, id=id))\n  names(EPICannobed) <- EPICannobed$id\n\n  probes <- EPICannobed[which(names(EPICannobed) %in% target_IDs)]\n  all_probes <-EPICannobed[which(names(EPICannobed) %in% allProbe_IDs)]\n  ##Stratified sampling of same number of probes from ctrl probe list based on categolies of CGIs, shores, and non CGIs\n  ##definition of CpG island and shore\n  data(hg19.islands)\n  hg19.shores <- c(flank(hg19.islands, 2000, start=TRUE),flank(hg19.islands, 2000, start=FALSE))\t#definign of shores (defined as 2kb up/down stream from CGI)\n  ## identification of DMPs in each categolies\n  CGI.probes <- subsetByOverlaps(probes, hg19.islands)\t#identification of CGI DMPs\n  shore.probes <- subsetByOverlaps(probes, hg19.shores)\t#identification of shore DMPs\n  shore.probes <- shore.probes[!shore.probes %in% CGI.probes] #In case of overlap to two categolies, CGI is priolity\n\n  ## number of DMPs in each categilies\n  nCGI.probes <- length(CGI.probes)\t#number of CGI DMPs\n  nshore.probes <- length(shore.probes)\t#number of shore DMPs\n  nnonCGI.probes <- length(probes)-nCGI.probes-nshore.probes\t#number of non-CGI/non-shore DMPs\n\n  ##Categolization of all probes into the categolies\n  CGI.ctrlProbeList <-names(subsetByOverlaps(all_probes, hg19.islands))\t#identification of all CGI probes\n  shore.ctrlProbeList <- names(subsetByOverlaps(all_probes, hg19.shores)) #identification of all shore probes\n  shore.ctrlProbeList <- shore.ctrlProbeList[!shore.ctrlProbeList %in%CGI.ctrlProbeList]#In case of overlap to two categolies, CGI is priolity\n  nonCGI.ctrlProbeList <- setdiff(setdiff(allProbe_IDs, names(CGI.ctrlProbeList)), names(shore.ctrlProbeList))\t#identification of all no-CGI/non-shore probes\n\n  ##number of probes in each categolies\n  nCGI.ctrlProbeList <- length(CGI.ctrlProbeList) #number of all CGI probes\n  nshore.ctrlProbeList <- length(shore.ctrlProbeList)\t#number of all shore probes\n  nnonCGI.ctrlProbeList <- length (nonCGI.ctrlProbeList)\t#number of all non-CGI/non-shore/probes\n\n  ##ramdom sampling from each categolies\n  CGI.runProbeList <- CGI.ctrlProbeList[floor(runif(nCGI.probes, 1 ,nCGI.ctrlProbeList))]\t#random sampling from CGI probes\n  shore.runProbeList <- shore.ctrlProbeList[floor(runif(nshore.probes, 1 ,nshore.ctrlProbeList))]\t#random sampling from shre probes\n  nonCGI.runProbeList <- nonCGI.ctrlProbeList[floor(runif(nnonCGI.probes, 1 ,nnonCGI.ctrlProbeList))] \t#random sampling from non-CGI/nin-shore probes\n  runProbeList <- c(CGI.runProbeList, shore.runProbeList, nonCGI.runProbeList)\n  return (runProbeList)\n}\n\nseqExtract<- function(positions, genome , seq_range = c(-5000,5000)){ #sequence extraction\n  seq_length <- seqlengths(genome)\n  positions <- positions[(positions[,1] != \"\"),]\n  chrom <- positions[,1]\n  start <- as.numeric(positions[,2])-(seq_range[2]*1)\t## lower range from CpG\n  end <- as.numeric(positions[,2])+(seq_range[2]*1)\t\t## upper range from CpG\n  seqRange <- cbind(chrom, start, end)\n  seqRange <- seqRange[(as.numeric(seqRange[,2]) >= 0) & (as.numeric(seqRange[,3]) <= seq_length[seqRange[,1]]),]\n  fasta2 <- getSeq(genome, name=seqRange[,1], start=as.numeric(seqRange[,2]), end=as.numeric(seqRange[,3]))\n  names(fasta2) <- rownames(positions)\n  return (fasta2)\n}\n\nwriteSplitSeq <- function(seqs, split_num, output_file){\n  n_target_seq <- length(seqs)\n  ref_point <- 0\n  all_filenames <- NULL\n  while(ref_point < n_target_seq){\n    seqsplit_str <- 1 + ref_point\t#start number of sequences\n    seqsplit_end <-seqsplit_str + split_num -1\t#end number of sequences\n    if(seqsplit_end  > n_target_seq){ #for the last incomplete number set\n      seqsplit_end <-n_target_seq\n    }\n    split_seqs <- seqs[seqsplit_str:seqsplit_end]\n    filename <- paste(tempDir,\"/\",output_file,\"_\",seqsplit_str, \"-\", seqsplit_end,\".fa.tmp\" , sep=\"\")\n    all_filenames <- c(all_filenames, filename)\n    writeXStringSet(split_seqs, file=filename, format=\"fasta\")\n    ref_point <- ref_point+split_num  #range sliding\n  }\n  return(all_filenames) #to read the written files return the file names\n}\n\nmotifDistFromCpG <- function(pfm, DNAseq, half_length=half_length){ ##search pfm and output the distance from center\n  library(\"Biostrings\")\n  pwm_hits <- matchPWM(pfm,  subject=DNAseq,  min.score=\"80%\")## muchPWM provides the distance from 5'end of the sequence.\n  if (! identical(start(pwm_hits) , integer(0))) {\n    distsFromCpG <- start(pwm_hits) - half_length  ##Then the ditance from 5' is converted to that of from center (CpG position)\n    return(distsFromCpG)\n  }\n}\n\nmotifDistMultiSeqs <- function(motif, fasta2=fasta2){ ##Run motifDistFromCpG function for multiple sequence in pallarel with multi-CPUs\n  ##motif search\n  library(\"snow\")\n  library(\"Biostrings\")\n\n  pfm_jaspar_fw <- motif #retreave a pfm from motifDB\n  pfm_jaspar_rv <- reverseComplement(pfm_jaspar_fw) #complementary pfm\n  half_length <- (width(fasta2[1])-1)/2\n\n  ## Use multi-CPUs to compute distance from CpG\n  cl <- makeCluster(16,type=\"SOCK\")\n  clusterEvalQ(cl,library(\"Biostrings\"))\n  clusterExport(cl, \"motifDistFromCpG\", envir=environment())\n  clusterExport(cl, \"fasta2\",envir=environment())\n  clusterExport(cl, \"half_length\",  envir=environment())\n  clusterExport(cl, \"pfm_jaspar_fw\",  envir=environment())\n  clusterExport(cl, \"pfm_jaspar_rv\",  envir=environment())\n  motifPositions_fw <- parLapply(cl, fasta2, function(x){motifDistFromCpG(pfm=pfm_jaspar_fw, DNAseq=x, half_length=half_length)})\n  motifPositions_rv <- parLapply(cl, fasta2, function(x){motifDistFromCpG(pfm=pfm_jaspar_rv, DNAseq=x, half_length=half_length)})\n  stopCluster(cl)\n  motifPositions <- lapply(1:length(motifPositions_fw), function(x){\n    merged <- c(motifPositions_fw[[x]], motifPositions_rv[[x]])\n    return(merged)\n  })\n  names(motifPositions) <- names(motifPositions_fw)\n  return(motifPositions) #motifPositions is a list of identified motif positions in a region.\n}\n\nsplitSeqMotDist <- function(filenames,  motif_list){ #Splitted seqs are sequentially read and serch the pwm\n  target_positionsList <- lapply(1:length(motif_list), function(i){numeric()})  #an object to save result of motif search for all motifs\n  names (target_positionsList) <- names(motif_list)\n  count <- 1\n  for (i in filenames){ #read the multi-fasta file names one by one\n    print(paste(i,\" is processing......\", count, \"/\",length(filenames), sep=\"\"))\n    fasta2 <- readDNAStringSet(i)\t#read the multi-fasta file as DNAStringSet\n    target_posi_subList <- lapply(motif_list, function(x){motifDistMultiSeqs(motif = x, fasta2 = fasta2)})\t#target_posi_subList is a list of lists of identified motif positions in a region for each motif.\n    for (j in 1:length(target_posi_subList)){\n      target_positionsList[[j]] <- c(target_positionsList[[j]],target_posi_subList[[j]] )\t#save the result to an List object\n    }\n    count <- count+1\n    rm(fasta2)\n    print(\"Done...\")\n  }\n  return(target_positionsList)\n}\n\nmotHist <- function(target_mot_posi, ctrl_mot_posi, seq_range=seq_range){ #Vidualization by histgram\n  ## Input objects are 1) motif position fils of target and 2)control\n  if((length(target_mot_posi != 0)) && (length(ctrl_mot_posi != 0))){\n    ##plot a histgram\n    breaks <- 400\n    target_hist_para <- hist(target_mot_posi, breaks=breaks, plot=FALSE) #parameters for histgram in target sequences\n    ctrl_hist_para <- hist(ctrl_mot_posi, breaks=breaks, plot=FALSE)  #parameters for histgram in random sequences\n    hist_freqs <- c(target_hist_para$counts, ctrl_hist_para$counts)\n    y.limit.max <- (max(hist_freqs) *1.1)  #y max of plot area\n    main<-paste(motGene[j], \"(histgram)\", sep=\"\") #main title\n    hist(target_mot_posi, xlim=c(seq_range[1],seq_range[2]), ylim=c(0, y.limit.max), breaks=breaks, freq=TRUE, main=main, col = \"#ff00ff40\", border = NA, xlab=\"Distance from CpG\", ylab=\"Frequency\", cex.axis=0.7)\n    hist(ctrl_mot_posi, xlim=c(seq_range[1],seq_range[2]),  ylim=c(0, y.limit.max), breaks=breaks, freq=TRUE, main=\"\",col = \"#0000ff40\", border = NA,, xlab=\"\", ylab=\"\", add=TRUE, cex.axis=0.7)\n  }\n}\n\nenrichScore <- function(x = point ,y=target,z=ctrl, nProbeList = nDMP_IDs){ #computation of enrichment score\n  ##Mixture distribution of karnel densities per region\n  ##karnel = gaussian\n  ##x: x value of this function\n  ##target: taget distribution data  to be tested\n  ##ctrl: control distribution data(motif distribution of ramdomly selected seqs)\n  demethy_length <- length(y)\n  random_length <- length(z)\n  b_width <-50\t\t\t\t\t\t #bw.nrd0(integ)\n  gaus_demethy <- (exp(-((((y-x)/b_width)^2)/2)))/(sqrt(2*pi))\n  gaus_random <- (exp(-((((z-x)/b_width)^2)/2)))/(sqrt(2*pi))\n  mixed_gaus <- sum(gaus_demethy)-sum(gaus_random)  #Background subtraction\n  enrichment_score <- mixed_gaus/nProbeList  ##normalized by region number\n  return(enrichment_score)\n\n}\n\nenrichScoreDist <- function(target_mot_posi, ctrl_mot_posi, seq_range=seq_range, plot_draw=TRUE){\t#Plot of enrichment score and return enrichment scores\n  ## Input objects are motif position fils of 1)target and 2)control\n  if((length(target_mot_posi != 0)) && (length(ctrl_mot_posi != 0))){\n    ranks <- seq(seq_range[1], seq_range[2], length=1001)\n    ranksList <- as.list(ranks)\n\n    ## Use clusters (multiple CPUs)\n    library(\"snow\")\n    cl <- makeCluster(16,type=\"SOCK\")\n    clusterExport(cl, \"enrichScore\", envir=environment())\n    clusterExport(cl, \"ranks\", envir=environment())\n    clusterExport(cl, \"target_mot_posi\",  envir=environment())\n    clusterExport(cl, \"ctrl_mot_posi\",  envir=environment())\n    clusterExport(cl, \"nDMP_IDs\",  envir=environment())\n    enrichment_scores <- parLapply(cl, ranks, function(x){enrichScore(x=x, y = target_mot_posi, z = ctrl_mot_posi, nProbeList = nDMP_IDs)})\n    stopCluster(cl)\n    enrichment_scores <- unlist(enrichment_scores)\n\n    if(plot_draw==TRUE){\t#plot the enrichment score\n      library(ggplot2)\n      library(reshape2)\n      library(RColorBrewer)\n\n      yLimitMixture <- c(min(enrichment_scores*1.1), max(enrichment_scores *1.1)) #y max of the plot area\n      main<-paste(motGene[j], \"(mixture distribution)\", sep=\"\") #main title\n      data <- as.matrix(enrichment_scores)\n      rownames(data) <- ranks\n      colnames(data ) <- \"ES\"\n      data.df <- melt(data)\n      names(data.df) <- c(\"dist\", \"sample\", \"ES\")\n\n      g <- ggplot(data.df, aes(x = dist, y = ES,  group = sample, colour = sample))\n      g <- g + geom_line()\n      g <- g + scale_colour_brewer(palette = \"Set1\")\n      #g <- g + ylim(c(-0.01,0.03))\n      g <- g + xlab(\"Distance from CpG\")\n      g <- g + ylab(\"Enrichment Score\")\n      #g <- g + guides(fill=guide_legend(title=NULL))\n      g <- g + geom_hline(yintercept=0)\n      g <- g + theme(axis.text.x = element_text( color =\"black\",size=14), axis.text.y = element_text(color = \"black\", size=14), axis.ticks=element_line(color=\"black\", size=.5), axis.title=element_text(color=\"black\", size=14))\n      g <- g + theme(panel.background=element_rect(fill=\"white\", color=NA), panel.border=element_rect(fill=NA, color=\"black\"), panel.grid.major=element_blank(), panel.grid.minor=element_blank())\n      #g <- g + theme(legend.position=c(.85,.85))\n      #g <- g + theme(legend.background=element_rect(fill=\"white\"))\n      g <- g + theme ()\n      plot(g)\n    }\n    return(enrichment_scores) #returen the result of moxiture distribution\n  }\n}\n\nmotifClassCount <- function(motifPosi, windowSize = windowSize, slide = slide, seq_range=seq_range){\n  relativePosi <- 0\n  freqs <- NULL\n  class <- NULL\n  windowStr <- seq_range[1] + relativePosi\t#intitial start position\n  windowEnd <- windowStr + windowSize\t#intial end position\n  while(windowEnd <= seq_range[2]){\t#sliding\n    windowStr <- seq_range[1] + relativePosi #5' of window end\n    windowEnd <- windowStr + windowSize #3' of window end\n    class <- c(class, windowStr+(windowSize/2)) #class (center of window)\n    freqs <- c(freqs,sum((motifPosi >= windowStr) & (motifPosi <= windowEnd))) #counting of motif frequency\n    relativePosi <- relativePosi+slide #Window sliding\n  }\n  freqs <- freqs\n  motifCounts <- cbind(class, freqs)\n  return (motifCounts)\n}\n",
    "created" : 1519363510273.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3179650713",
    "id" : "564BFCD4",
    "lastKnownWriteTime" : 1519363556,
    "last_content_update" : 1519363556726,
    "path" : "~/InfiniumDiffMetMotR/R/InfiniumDiffMetMot.R",
    "project_path" : "R/InfiniumDiffMetMot.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}